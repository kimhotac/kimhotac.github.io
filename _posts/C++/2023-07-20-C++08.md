toc: true
---
# 08 함수의 활용

---

### 08.1 인라인(inline) 함수

프로그램의 실행속도를 높이기 위해 C++에 추가
컴파일러가 프로그램 내부구조를 어떻게 결합하는가에 차이

**기존함수**
다른주소로 점프 메모리에 레지스터 값들 저장, 스택에 매개변수 복사
함수가 시작하는 메모리 주소에서 함수 실행
함수의 리턴값을 가지고 레지스터에 저장, 기존 주소의 명령으로 복귀

**C++인라인 함수**

- 함수 내부코드에 호출할 인라인 함수의 코드를 직접 삽입
- 자리에서 바로 처리
- 메모리에서 단점이 발생
- 같은함수가 여러번 반복되는 경우에 시간이 졀약된다.
- 함수에 걸리는 시간이 짧을 경우에 의미가 있다.

**인라인 함수 사용법**

- 함수 선언 앞에 inline
- 함수 정의 앞에 inline

둘중 한 가지를 작성해야 한다.
원형을 생략하고 원형자리에 정의를 놓는것이 일반적이다.

---

### 08.2 참조 변수

참조변수 - 미리 정의된 변수명 대신 사용 가능한 이름

```cpp
#include <iostream>
using namespace std;

int main()
{
    int a = 123; //초기화
    int& b = a; //참조 (int * const p = &a;와 본질적으로 같다)
    int *p = &a; //포인터
    cout << a << " = " << b << " = " << *p << endl;
    cout << &a << " = " << &b << " = " << p;
}
//출력값
//123 = 123 = 123
//0x7ffca1213564 = 0x7ffca1213564 = 0x7ffca1213564

```

참조는 만들때 반드시 초기화를 해야한다.

**함수 매개변수로서의 참조**

참조로 전달 - 함수의 매개변수를 참조로 넘기는 것을 의미한다.
- 원본 데이터 수정이 가능하다.
- 인자로 받을 때 &연산자를 함수 정의와 원형에 넣어주면 참조로 전달이 가능하다.
- 구조체나 클래스와 같은 큰 데이터를 다룰 때 효율적인 메모리 공간 사용이 가능하다.

**임시변수, 참조 매개변수,const**
실제 매개변수와 참조 매개변수가 일치하지 않을 떄 임시변수를 생셩한다.

참조변수가 const인 경우 컴파일러는 두가지 상황에서 임시변수를 생성한다.
- 실제 매개변수가 올바른 데이터 형이지만 lvalue가 아닐 때
- 실제 매개변수가 잘못된 데이터 형이지만 올바른 데이터형으로 변환할 수 있을 때

lvalue - 표현식 이후에도 사라지지 않는 값, 특정 주소에서 다시 접근 가능한 값

```cpp
void sample(const int &a)
...
int b = 1;
sample(b); // 같은 데이터형 객체이므로 참조 가능
int *c = &b;
sample(*c); // 같은 데이터형 객체이므로 참조 가능
int &d = b;
sample(d); // 같은 데이터형 객체이므로 참조 가능
int f[2] = {1,1};
sample(f[1]);  // 같은 데이터형 객체이므로 참조 가능
double e = 1;
sample(e); //데이터형이 다르므로 참조 불가능
sample(1); //데이터 형은 일치하지만 특정주소로 다시 접근이 불가능 해 임시변수 생성
sample(b+1); //데이터 형은 일치하지만 특정주소로 다시 접근이 불가능 해 임시변수 생성
```
임시변수는 함수가 호출되어있는 동안 유지된다.

실제 매개변수로 전달되는 변수를 변경하는 것이 목적일 경우 임시변수가 불가능하게 만든다.

최근 C++표준에서는 임시변수의 생성을 허용하지 않는다. 라고 책에서 써있지만 
```cpp
#include <iostream> //C++ , 14, 17, 20에서 잘 돌아가는 코드이다.
using namespace std;
void sample (const int &a);

int main()
{
    sample(1);
    return 0;
}

void sample(const int &a) // 임시변수를 할당 받지만 코드가 잘 돌아간다.
{
    cout << a;
    return;
}
//출력 : 1
```

함수호출시 lvalue가 아니거나 const참조 매개변수의 데이터형이 일치하지 않을 때, 정확한 데이터형의 익명 변수를 생성해 값을 넣고 익명 변수를 참조한다.

**참조 형식 매개변수를 const로 선언하는 이유**
- 참조 매개변수에서 값을 변경할 필요가 없는 경우 데이터 변경을 막을  수 있다.
- 실제 매개변수가 const인 경우도 처리 할 수 있다.
- const를 사용하면 필요에 따라 임시변수를 생성 할 수 있다.

**구조체에 대한 참조**
참조는 사용자 정의 데이터형(구조체, 클래스)을 다룰 때 유용하다.

함수의 원형을 예시로 들어보면
```cpp
struct A
{
	...
}
... //man에 대한 참조를 하는 원형
void B(A &b); //b를 통해 구조체를 참조한다.
void C(const A &c); //구조체를 변경할 수는 없다.
```

**참조를 리턴하는 이유**
값 리턴시 - 값을 임시장소에 복사하고 그 값을 다시 대입할 것이다.
참조 리턴시 - 리턴을 받은 변수에 직접 저장되기때문에 효율적인 방법이다.

**참조를 리턴할 때 주의 할 점**
함수가 끝나며 같이 메모리 할당이 끝나는변수에 참조를 리턴하지 않게 주의해야한다.
매개변수로 전달된 참조를 리턴하거나 new를 사용해야한다.

**클래스 객체와 참조**

클래스 객체 또한 참조 연산자를 통해 같은 형식으로 사용 가능하다.
참조변수 또한 클래스의 메소드들을 사용할 수 있다.

**(정리)참조매개변수는 언제 사용하는가?**

사용하는 이유
- 호출 함수에 있는 데이터 객체의 변경을 허용하기 위해
- 전체 데이터 객체 대신에 참조를 전달하여 프로그램의 속도를 높이기 위해

함수가 전달된 데이터를 변경하지 않고 사용만 하는 경우
- 기본 데이터형이나 작은 구조체라면 값으로 전달
- 배열이라면 포인터만 사용 가능하다. const를 지시하는 포인터로 전달한다.
- 큰 구조체라면 포인터나 참조를 const 로만든다.
- 클래스 객체라면 const 참조를 사용한다. 클래스 객체 매개변수 전달은 참조가 표준이다.

함수가 호출 함수의 데이터를 변경하는 경우
- 데이터 객체가 기본 데이터형이면 포인터를 사용한다
- 배열이면 포인터만 사용 가능하다.
- 구조체이면 참조 또는 포인터를 사용한다.
- 클래스 객체이면 참조를 사용한다.

---
#### 08.3 디폴트 매개변수

디폴트 매개변수는 함수 호출에서 매개변수를 생략했을 경우에 대신 사용되는 값이다.

형식은 다음과 같다.
`int sample(int n = 1);`

디폴트 매개변수보다 오른쪽에 있는 모든 매개변수는 모두 디폴트 매개변수다.
```cpp
int sample(int n , int m = 2); //가능하다.
int sample(int n = 1, int m); //불가능하다.
```

함수정의는 디폴트 매개변수가 없을 떄와 동일하게 사용한다.

---
#### 함수 오버로딩

**함수 오버로딩(function overloading), 함수의 다형(polymorphism)**
>여러개의 함수가 하나의 이름을 공유하는 것

함수 시그니처(fuction signature)을 통해 함수를 구분한다
함수 시그니처는 함수의 매개변수 리스트이다.
시그니처는 매개변수의 개수, 데이터형, 매개변수 순서로 구분한다.
```cpp
int A(int a); //이 두가지는 공존 할 수 없다
int A(int &a); //시그니처를 가지고 구분할 수 없다
```
데이터형과 그에 대한 참조를 같은 시그니처로 구분한다.

```cpp
void A(int *a);
void A(const int *a);
...
int p = 1;
A(const &p);
A(&p);
```
const와 const가 아닌 변수는 구별한다.

**함수 오버로딩은 언제 사용하는가?**
* 기본적으로 같은 작업을 수행하는 함수들에만 사용한다.
* 디폴트 매개변수로 가능하다면 대체하는 것이 좋다.

---
#### 08.5 함수 템플릿

함수 템플릿 - 함수의 일반화 서술
template 키워드를 사용해 여러개의 데이터형을 함수 호출시에 맞는 데이터형으로 맞추어서 컴파일러가 함수를 생성해 제공한다.

```cpp
//함수 템플릿 원형
template <class Any> //Any자리에 다른 것을 사용 가능하다 ex)a,b,c
void function(Any &a, Any &b);
//함수 템플릿 정의
template <class Any>//class대신에 typename을 사용 가능하다.
void function(Any &a, Any &b)
{
...
}
```
최종코드에는 템플릿이 포함되지 않고 적절한 데이터 형으로 변환된 함수들이 포함되어있다.
모든 템플릿 매개변수가 템플릿 매개변수형일 필요가 없다.
템플릿은 일반적으로 헤더파일에 위치한다.

**템플릿의 오버로딩**
다른 데이터형에 다른 알고리즘을 적용하는 함수가 필요할 때 사용한다.
확실하게 구분되는 함수 시그니처를 사용해야 한다.

**템플릿 제한**
구조체 덧셈 연산, 배열의 대입등 오류가 발생하는 데이터형들이 존재할 것이다.
이 경우 특화된 템플릿 정의를 제공해야한다.

**명시적 특수화**
특정 데이터형에 특수화된 함수 정의를 코드와 함께 제공할 수 있다.

3세대 특수화
```cpp
//1. 템플릿이 아닌 함수 원형
void function(int &);
//2. int형을 위한 명시적 특수화
template <> void function<int>(int &);
//3. 템플릿 원형
template <typename t>
void function(T &);
```
위 코드에 있는 함수들은 모두 오버로딩 버전도 가질 수 있다.
컴파일러 우선순위가 존재한다.
(함수원형 -> 명시적특수화 -> 템플릿 원형) 순으로 선택한다.

**오래된 특수화 형식**
특정 데이터형에 맞게 정의된 일반함수를 제공한다.
만일 더 과거의 버전 컴파일러를 사용한다면 템플릿이 아닌 함수 원형을 선택하기 때문에
`void function<int>(int &);`// 오래된 특수화 형식을 사용해야한다.


**템플릿의 구체화(instantiation)**
컴파일러가 템플릿에 따라 특정 데이터형에 맞는 함수정의를 생성한 것

**암시적 구체화 (implicit instantiation)**
매개변수를 통해 템플릿의 구체화를 사용한다.
-과거에는 유일한 방법

**명시적 구체화(explicit instanitiation)**
```cpp
template void function<int>(int);
//의미 : function템플릿을 사용해 int 형에 맞는 구체화를 생성하라
```

** 명시적 특수화(explicit specialization)**
```cpp
template <> void function<int>(int &); 
template <> void function(int &); 
//의미 : 함수를 function템플릿을 사용하지 말고 int형에 특별하게 정의된 함수정의를 사용하라
```
**특수화(specialization)**
특수화 - 구체적인 데이터형을 사용하는 함수 정의
암시적 구체화, 명시적 구체화, 특수화를 모두 특수화라고 한다.
동일한 데이터형에 명시적 구체화와 명시적 특수화를 같이 사용할 수 없다.
