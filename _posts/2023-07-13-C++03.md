# 03 데이터 처리

---

### 03.1 간단한 변수

정보를 저장하기 위해서는 3가지 정보가 필요하다.

- 어디에 저장되는가?
- 어떤 값이 저장되는가?
- 어떤 종류의 정보인가?

기본적인 방법은 변수를 선언하는 것이다.

데이터 형이 정보의 종류를 나타내고, 변수의 이름은 저장되는 메모리의 주소를 추상화 한 것이다.

이후 어떤 값을 저장하는지는 변수명을 통해 값을 대입한다.

**변수 이름**

변수명을 사용하기 위해서는 몇가지 규칙을 따라야한다.

- 변수 이름에는 영문자, 숫자, 밑줄(underscore) 문자만을 사용 할 수 있다.
- 숫자를 변수 이름의 첫 문자로 사용할 수 없다.
- 변수 이름에서 대문자와 소문자는 구별된다.
- C++의 키워드는 변수 이름으로 사용할 수 없다.
- 두 개의 밑줄 문자로 시작하는 이름이나, 밑줄 문자와 대문자로 시작하는 이름은, 그것을 사용하는 컴파일러와 리소스가 사용하기로 예약되어있다.
- 한 개의 밑줄 문자로 시작하는 이름은 그것을 사용하는 컴파일러와 리소스가 전역 식별자(global identifier)로 사용하기로 예약되어있다.
- 변수 이름의 길이는 제한이 없으며, 변수 이름에 쓰인 모든 문자들이 유효하다. 일부 플랫폼에서는 길이 제한이 있다.

언더 스코어로 시작하는 변수 명 들은 컴파일러 에러가 발생하지 않지만 정의되지 않은 동작을 수행한다는 점에서 다른 규칙과는 다르다.

두 개 이상의 단어를 연결해서 변수 명을 사용할 때에는 두 가지 스타일을 사용한다.

- (_)언더 스코어를 사용해 단어를 구분하는 방법
- 단어의 첫 글자를 대문자로 표기하는 방법

**정수형**

정수 - 소수부가 없는 수를 의미한다.

메모리 용량의 한계점 때문에 여러 폭을 가지는 정수형을 제공한다.

폭 - 정수를 저장하는데 사용되는 메모리의 크기

**short, int, long, long long 정수형**

위의 4가지 정수형은 정수 저장에 사용하는 폭의 크기가 다르다.

모든 컴퓨터에서 최적의 선택은 없다. 따라서 표준에서는 최소 크기만을 정의한다.

- short : 최소한 16비트 폭 만을 가진다.
- int : 최소한 short 만큼은 크다.
- long : 최소한 32비트 폭을 가지며, 최소한 int 만큼은 크다.
- long long : 최소한 64비트 폭을 가지며, 최소한 long만큼은 크다.

많은 C++이 short-16bit, long-32bit로 사용한다.

int는 표준에 맞게 여러가지 폭을 사용한다.

일반적이지 않은 폭을 가져도 climits 헤더 파일 또는 sizeof() 등을 통해 최댓값과 최솟값을 알 수 있다.

**sizeof 연산자**

sizeof 연산자 데이터 형 이름에는 괄호와 사용하고, 변수 이름에는 괄호를 사용하지 않아도 된다.

데이터 형의 폭을 바이트 단위로 리턴한다.

**climits 헤더파일**

climits 헤더 파일은 데이터형의 한계 값을 기호 상수로 나타낸다. 아래와 같은 기호 상수와 의미를 가진다.

| 기호상수 | 의미 |
| --- | --- |
| CHAR_BIT | 비트 필드가 없는 가장 작은 변수의 비트 수 |
| SCHAR_MIN | signed char 형식 변수의 최소 값 |
| SCHAR_MAX | signed char 형식 변수의 최대 값 |
| UCHAR_MAX | unsigned char 형식 변수의 최대 값 |
| CHAR_MIN | char 형식 변수의 최소 값 |
| CHAR_MAX | char 형식 변수의 최대 값 |
| MB_LEN_MAX | 여러 문자 상수에서 최대 바이트 수 |
| SHRT_MIN | short 형식 변수의 최소 값 |
| SHRT_MAX | short 형식 변수의 최대 값 |
| USHRT_MAX | unsigned short 형식 변수의 최대 값 |
| INT_MIN | int 형식 변수의 최소 값 |
| INT_MAX | int 형식 변수의 최대 값 |
| UINT_MAX | unsigned int 형식 변수의 최대 값 |
| LONG_MIN | long 형식 변수의 최소 값 |
| LONG_MAX | long 형식 변수의 최대 값 |
| ULONG_MAX | unsigned long 형식 변수의 최대 값 |
| LLONG_MIN | long long 형식 변수의 최소 값 |
| LLONG_MAX | long long 형식 변수의 최대 값 |
| ULLONG_MAX | unsigned long long 형식 변수의 최대 값 |

**초기화**

초기화는 선언구문과 대입구문을 한줄로 조합한 형태이다.

```cpp
int a = 1;   //C 스타일
int a(1);    //C++에서 지원하는 초기화 문법
int a = {1}; //{}중괄호도 사용 가능하다.
int a{1};    //{}중괄호도 사용 가능하다.
```

변수의 초기 값을 안다면 반드시 초기화 한다.

초기화를 통해 변수에 값을 대입하지 않는 실수를 예방 가능하다

형 변환 오류를 방지할 수 있다

**unsigned형**

(short, int, long, long long)은 음의 정수값을 저장할 수 없는 unsigned 변형을 가진다. 만일 unsigend 키워드를 앞에 붙여 선언하면 음의 정수값을 저장하지 않아 최댓값이 늘어나는 장점이 있다.

하지만 반드시 양수로만 나타나는 값에만 사용한다.

**정수의 overflow**

자료형이 표현할 수 있는 한계 값을 벗어나면 표현 범위의 반대부터 다시 시작한다.

**어떤 정수형을 선택할 것인가?**

불가피하게 다른 정수형을 사용하는 경우가 아니라면 int형을 사용한다.

short형이 int 형 보다 크기가 작을 경우, short 형을 사용하는 것이 메모리를 절약 할 수 있다. (특히 길이가 긴 정수 배열을 사용할 때)

메모리 절약이 중요한 경우는 폭이 같더라도 short 형을 사용하는 것이 유리하다. 다른 시스템에 이식 되어 short 형의 폭이 작은 경우, 메모리 공간을 효율적으로 사용 가능하다.

정수형 상수

8진법, 10진법, 16진법을 각각 아래의 조건을 통해 인식한다.

| 10진 | 첫 숫자가 1~9일 경우 |
| --- | --- |
| 8진 | 첫 숫자가 0 이고, 두 번째 숫자가 1에서 7일 경우 |
| 16진 | 첫 두 글자가 0x, 0X에 해당할 경우 |

cout을 통하면 항상 10진수로 출력한다.

cout에는 출력하는 정수들을 몇 진수로 출력할 것인지 정하는 조정자를 제공한다.

각각 10진수는 dec, 8진수는 oct, 16진수는 hex로 출력하는 정수의 진법을 바꿀 수 있다.

**C++가 상수의 데이터 형을 결정하는 방법**

```cpp
cout << "year = " << 1492 << "\n"
```

프로그램은 정수의 데이터 형을 기본적으로 int형으로 처리한다.

int형보다 크거나, 정수에 특정 데이터 형의 접미어를 붙였을 때에는 다른 데이터 형으로 처리한다.

접미어는 상수 끝에 붙는 문자로 상수의 데이터 형을 나타낸다.

| long | l,L |
| --- | --- |
| unsigned | u,U |
| long long | ll,LL |

접미어가 없는 10진 정수는 int, long, long long 중 가장 작은것으로 나타낸다

접미어가 없는 8진, 16진 정수는 int, unsigned int, long, unsigned long, long long, unsigned long long 중 크기가 가장 작은 것으로 나타낸다.

**char형 : 문자와 작은 정수**

- char은 문자와 숫자를 저장하기 위한 것이다.
- 문자를 수치코드로 나타낸다.
- 대부분의 컴퓨터 시스템은 256개보다 적은 개수의 문자들을 지원, 1바이트로 충분히 나타낸다.
- 문자들을 처리하거나 short 형보다 작은 범위의 정수를 나타낼 수 도 있다.

가장 많이 사용되는 문자 세트는 ASCII이다.

아래는 아스키 코드 문자표 링크이다.

[ASCII](https://ko.wikipedia.org/wiki/ASCII)

C++에서는 넒은 범위를 수용하는 Unicode를 지원한다.

문자상수는 ‘를 사용하고

문자열은 “를 사용한다.

**멤버함수**

객체 지향에서 굉장히 중요하다.

멤커함수는 클래스에 속하고 데이터를 다루는 방법을 정의한다.

```cpp
객체명.멤버함수() //이것과 같은 형식으로 사용한다.
```

**cout.put()**

cout.put()은 <<연산자를 사용하여 문자를 출력하는 것에 대한 대안이다. 과거에 문자 변수는 문자로 출력했지만 문자 상수를 수로 출력하는 문제들이 있어 cout.put(’문자상수’)를 통해 출력했었다.

**char형 상수**

일반적인 문자들을 나타내는 방법은 작은따옴표로 그 문자를 둘러 싸는 것이다.

이 방법은 직접 수치 코드의 숫자를 입력하는 것 보다 좋다. 특정 수치 코드에 종속적이지 않기 때문이다. 

**C++에서 특수한 문자들을 문자열에 입력**

C++에서 특수한 문자들과 개행문자는 문자열의 일부로 입력할 수 없다.  이스케이프 시퀀스가 필요하다.

아래는 이스케이프 시퀀스 표의 일부이다.

| 문자열 | 의미 |
| --- | --- |
| \a | 경보 문자 |
| \b | 백스페이스 |
| \f | 폼 피드(form feed) |
| \n | 개행 |
| \r | 캐리지 리턴 ( carriage return ) |
| \t | 수평 탭 |
| \v | 수직 탭 |
| \\ | 백슬래시 출력 |
| \' | 작은따옴표 출력 |
| \" | 쌍따옴표 출력 |

이스케이프 시퀀스는 문자 상수로 사용할 때는 작은따옴표로 감싸야한다.

```cpp
cout << endl;  //endl 조정자를 사용
cout << '\n';  //문자 상수를 사용한다.
cout << "\n";  //문자열을 사용한다.
```

위의 3줄 모두 같은 기능을 한다

```cpp
cout << "8자리 비밀번호를 입력하십시오:________\b\b\b\b\b\b\b\b";
```

위의 코드에서 \b 8개가 스트림에서 커서를 밑줄 문자위치로 옮긴다.

**유니버설 네임 코드**

C++ 시스템은 확장 문자를 지원한다. 유니버설 네임 코드를 사용하는 것은 이스케이프 시퀀스와 비슷하다. \u, \U중 하나로 시작하고 뒤에 16진수 숫자 4개가 온다.

하지만 다른 시스템에서 똑같은 숫자로 같은 문자를 표현한다는 보장을 할 수 없기에 유니코드가 아닌 유니버설 코드 네임 이라는 용어를 사용한다.

**signed char과 unsigned char**

int와는 달리 미리 정해져 있지 않다. 이는 하드웨어 특성에 맞추어 정할 수 있도록 하기 위함이다.

unsigned char은 -128~127, signed char은 0~255의 범위를 나타낼 수 있다.

**확장 char형 : wchar_t**

프로그램이 1바이트로 표현할 수 없는 문자 세트를 처리할 경우 사용한다. 

| char | wchar_t |
| --- | --- |
| 기본 문자 세트  | 확장 문자 세트 |
| 1byte | *기초 데이터 형 |
| cin, cout | wcin, wcout |

*기초 데이터 형 - 특정 정수형, 시스템에 따라 달라진다.

cin과 cout은 입출력을 wchar_t형을  처리하지 못한다. 따라서 wcin, wcout 객체를 제공한다.

확장 문자 상수나 확장 문자열은 앞에 L을 붙여서 나타낸다. ex) L”확장문자열”

**새로운 C++11형 : char16_t와 char32_t**

wchar_t 부호와 길이가 가변이기 때문에 문제가 발생할 수 있다.

접두사 u를 char16_t로, 접두사 U를 char32_t로 사용한다

**bool형**

부울형은 참(true), 거짓(flase)중 하나의 값만 가진다.

참은 1, 거짓은 0의 값을 가진다.

---

### 03.2 const 제한자

상수를 기호 이름으로 나타내면, 그 상수가 무엇을 의미하는 것인지 금방 알 수 있다.

코드에서 상수의 값을 바꿀 때에도 기호가 정의된 부분만 바꾸면 금방 해결 된다.

```cpp
const 자료형 상수명 = 상수;
```

한번 초기화를 하면 값이 고정된다. 변경하면 컴파일 에러가 발생한다.

값 변경을 제한하기 때문에 제한자(qualifier)라고 부른다.

const상수는 선언할 때 초기화 해야 한다. 선언 이후에 대입을 하면, 이미 미확정 값을 고정했기 때문에 오류가 발생한다.

일반적으로 상수들은 모두 대문자로 쓰거나, 맨 앞 문자만 대문자로 사용하거나, 앞에 k를 붙인다.

**const가 #define 보다 효과적인 점**

- 데이터 형을 명시 가능하다.
- C++의 활동 범위 규칙(scoping rules)을 적용해 특정 함수나 파일에만 사용 할 수 있도록 제한 할 수 있다.
- 배열이나 구조체 같은 복잡한 데이터 형에도 사용 가능하다.

---

### 03.3 부동 소수점수

소수부가 있는 수를 나타낼 수 있다. 매우 큰값을 나타낼 수 있다.

**부동 소수점수의 표기**

표기 방법은 2가지이다.

1. 일상생활에서 사용하는 소수점 표기법
2. 지수 표기(E notation)

**지수 표기(E notation)**

가수(mantissa)부와 지수(exponent)부로 나눌 수 있다.

모양은 (가수부)E(지수부)의 형태이다.

**부동 소수점형**

float, double, long double 세가지

유효숫자의 개수와 지수의 최소 허용 범위가 다르다

유효숫자는 의미를 가지는 숫자이다. 

지수는 유효숫자 뒤 0의 개수이다.

표준

- float : 최소 32비트
- double : float 보다 작지 않으면서, 최소 48비트
- long double : 최소한 double과 같은 크기

일반적으로 float-32bit, double-64bit, long double-(80,90,128)bit이다.

지수의 허용 범위는 세가지 모두 최소한 -37~37까지

다음의 링크는 MS의 VisualStudio2022 버전의 float 형식이다.

[float 형식](https://learn.microsoft.com/ko-kr/cpp/c-language/type-float?view=msvc-170)

간단히 살펴보면 double과 long double을 구분하지 않는다.

| 형식 | 지수 길이 | 가수 길이 |
| --- | --- | --- |
| float | 8비트 | 23비트 |
| double | 11비트 | 52비트 |

표준에서 float형의 유효 숫자는 6개이다. 유효숫자 이상으로 가수부에 유효숫자가 생길 경우 신뢰성에 문제가 생길 수 있다. 정밀한 숫자가 필요하다면 double 형을 사용해야한다.

**부동 소수점형 상수**

부동소수점형 상수를 사용하고 싶다면 float형은 f,F를 접미어로 double형은 l,L을 접미어로 사용하면 된다.

**부동 소수점수의 장단점**

장점

- 정수와 정수 사이의 값을 나타낼 수 있다.
- 스케일을 사용하여 정수에 비하면 큰 범위의 값을 나타낼 수 있다.

단점

- 수치 연산 보조 프로세서(math coprocessor)가 없으면 정수연산보다 속도가 느리다.
- 정밀도를 잃을 수 있다.

정수형과 부동 소수점 형을 합쳐 산술형이라고 부른다.

---

### 03.4 C++ 산술 연산자

**기본 산술 연산자 5개**

| 산술 연산자 | 설명 |
| --- | --- |
| + | 왼쪽의 피연산자에 오른쪽의 피연산자를 더함. |
| - | 왼쪽의 피연산자에서 오른쪽의 피연산자를 뺌. |
| * | 왼쪽의 피연산자에 오른쪽의 피연산자를 곱함. |
| / | 왼쪽의 피연산자를 오른쪽의 피연산자로 나눔. 피연산자가 모두 정수면 정수부만 반환한다. |
| % | 왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 후, 그 나머지를 반환함. 두 피연산자가 모두 정수여야 한다. |

산술 연산에서도 부동소수점의 정밀도 문제는 발생한다.

**연산 순서 : 우선순위와 결합 방향**

| 1 | * | 곱셈 연산자 | 왼쪽에서 오른쪽으로 |
| --- | --- | --- | --- |
|  | / | 나눗셈 연산자 | 왼쪽에서 오른쪽으로 |
|  | % | 나머지 연산자 | 왼쪽에서 오른쪽으로 |
| 2 | + | 덧셈 연산자 (이항 연산자) | 왼쪽에서 오른쪽으로 |
|  | - | 뺄셈 연산자 (이항 연산자) | 왼쪽에서 오른쪽으로 |

**나눗셈에 대한 보충**

나눗셈 연산자는 피연산자의 데이터형에 따라 결과가 달라진다.

정수 간의 연산은 정수로 반환한다.

부동소수점 형이 연산에 사용되면 부동소수점 형으로 반환한다.

**연산자 오버로딩 (operator overloading)**
C++에서는 기존의 언어에서 제공하고 있는 연산자에 대하여 그 의미를 다시 부여하는 것을 "연산자 오버로딩" 또는 "연산자 중복 (재정의)"라 한다.
연산자 오버로딩은 기본적으로 함수의 오버로딩과 같이 연산자도 하나의 함수라는 개념을 사용하여 중복 정의

**나머지 셈 연산자**

정수 나눗셈의 나머지를 리턴한다. 정수 나눗셈은 몫만 반환하므로 함께 사용하면 유용하다.

**데이터형 변환**

데이터형의 불일치를 해결하기 위해 다음 같은 상황에서 자동으로 데이터형 변환을 수행한다.

- 특정 데이터형의 변수에 다른 데이터형의 값을 대입했을 때
- 수식에 데이터형을 혼합하여 사용했을 때
- 함수에 매개변수를 전달할 때

**대입 구문에서의 데이터형 변환**

다른 데이터형의 변수에 대입하는 것이 자유롭다.

데이터형을 확장하는 변환은 문제가 생기지 않는다.

데이터형 변환에서 발생할 수 있는 문제점

| 데이터형 변환 | 잠재적인 문제점 |
| --- | --- |
| double → float (큰 부동 소수점형을 작은 부동 소수점형) | 정밀도(유효 숫자)가 손실된다. 원래 값이 변환 데이터형의 범위를 벗어날 경우, 결과를 예측할 수 없다. |
| 부동 소수점형을 정수형 | 소수부를 잃어버린다. 원래 값이 변환 데이터형의 범위를 벗어날 경우, 결과를 예측할 수 없다. |
| long → short (큰 정수형을 작은 정수형으로) | 원래 값이 변환 데이터형의 범위를 벗어날 경우, 대개 하위 바이트들만 복사된다. |

**{}를 사용할 경우의 초기화 변환(C++11)**

중괄호를 이용하여 리스트 초기화를 할 수 있다. 형변환에서 발생하는 문제점을 애초에 차단한다.

```cpp
long a = 1;
int b = {a}; //여기서 오류가 발생한다.
```

{}를 사용하면 컴파일러가 narrowing(협소화)를 허용하지 않는다.

**수식에서의 데이터형 변환**

C++는 어떤 수식의 값을 평가할 때 bool, cahr, unsigned char, signed char, short형 모두 int형으로 변환된다. 이러한 변환을 정수 승급(integral promotion)이라 한다. 

일반적으로 int형의 계산이 가장 빠르기 때문이다.

**C++11 버전에서 컴파일러가 검사를 진행하는 순서이다.**

1. 한쪽 피연산자가 부동 소수점형이면, 해당 부동 소수점형으로 변환한다.(큰 쪽으로)
2. 피연산자들이 모두 부동 소수점형이 아니라면, 정수형이므로 정수 승급이 일어난다.
3. 정수 승급이 일어난 경우, 양쪽 피연산자가 모두 signed이거나, 모두 unsinged일 경우 두 피연사자의 상대적 크기에 따라 큰 쪽으로 변환한다.
4. 두 피연산자의 signed, unsigned가 다를 경우, 상대적으로 큰 피연산자형으로 변환한다.
5. signed형이 unsinged형의 모든 값을 표현할 수 있다면, unsigned 피연산자가 signed형으로 변환된다.
6. 지금까지 해당되지 않을 경우, 양쪽 피연산자 모두 signed형의 unsigned형으로 변환된다.

**데이터형 변환자**

C++에서는 데이터형 변환자를 사용해 강제로 데이터형을 변환시킬 수 있다.

```cpp
(데이터형) 변수명 //변수명 을  데이터형 으로 강제로 변환한다 .
데이터형 (변수명) //변수명 을  데이터형 으로 강제로 변환한다 .
static_cast<데이터형> (변수명) //C++에서 사용이 제한적인 데이터형 변환 연산자를 도입했다.
```
