# 07 함수- C++의 프로그래밍 모듈

---
#### 07.1 함수의 기초

**함수 사용시 3가지가 필요하다.**
- 함수 정의
- 함수 원형
- 함수 호출

함수 정의는 라이브러리 함수에 컴파일 되어있다.

함수 원형을 제공하기 위해 라이브러리 헤더파일을 사용한다.

**함수정의**
```cpp
void 함수명(매개변수) //리턴값이 존재한다면 리턴값의 자료형이 void 대체
{
	...
	return 리턴값; //함수의 종료
}
```

**함수 원형**

컴파일러가 함수 원형을 가지고 처리 하는 일
- 함수의 리턴값을 바르게 처리한다.
- 정확한 개수의 매개변수를 사용했는지 확인한다.
- 정확한 자료형의 매개변수를 사용했는지 검사한다. 다르다면 자료형을 변환한다. (가능한 경우)

```cpp
void 함수명 (매개변수); //리턴값이 존재한다면 리턴값의 자료형이 void 대체
```

---
#### 07.2 함수 매개변수와 값으로 전달하기

매개변수 - 함수에 값을 전달하는 방법

형식 매개변수(formal parameter)에 기존변수에 존재하는 값을 복사해 사용한다.

호출되어 대입했던 기존 변수는 호출된 함수에서 값은 변경해도 영향이 없다.

여러개의 매개변수를 사용할 수 있다.

---
#### 07.3 함수와 배열

함수에서 배열을 넘기는 경우는 포인터로 넘긴다.
- 배열이 크기가 크면 메모리 공간이 낭비 될 수 있기 때문에 포인터로 사용한다.
- 배열의 이름이 인덱스 0의 주소값과 같기 때문에 매개변수로 넘겨 기존 배열처럼 사용 가능하다.
- 배열을 직접 접근하는 것이라 값을 변경 가능하기 때문에 유의해야한다.

```cpp
#include <iostream>
using namespace std;
void sample(int arr[]);

int main()
{
    int data[3] = {1,2,3};
    cout << data << endl; //배열 이름 출력
    sample(data);
}

void sample(int arr[])
{
    cout << &arr[0] << endl //0번인덱스 시작 주소 출력
         << "arr[1] : " << arr[1] <<endl //배열 인덱싱을 통한출력
         << "*(arr+1) : " << *(arr+1); // 포인터 덧셈연산을 통한 출력
    return;
}
//출력값 :
//0x7ffd52f2e9ec
//0x7ffd52f2e9ec
//arr[1] : 2
//*(arr+1) : 2
```

함수 매개변수 부분에 const제한자를 사용하면 배열의 내용을 변경할 위험성을 없앨 수 있다.

`void smaple(const int arr[], int n);`모양의 함수원형이라면 arr가지고는 데이터를 변경할 수 없다.

일반적으로 함수에 배열을 넘길때 배열 원소의 개수를 같이 넘긴다.

이유는  매개변수로 전달하다보면 sizeof를 사용할수 없어 배열의 개수를 파악할 수 없다.

**배열의 범위를 사용하는 함수**

배열의 시작 포인터와 배열의 마지막 인덱스의 다음 포인터를 전달 하는 방법이 있다.

인덱싱을 하다 전달받은 마지막  포인터와 같아지면 배열이 끝난 것을 사용한다.

**포인터와 const**

아래 세가지 경우가 있다.
```cpp
//이 경우 p를 사용해 a의 값을 변경 할 수 없다.
int a = 1;
const int *p = &a;
```
```cpp
//이 경우 p를 사용해 a의 값을 변경할 수 없지만 선언은 가능하다.
const int a = 1;
const int *p = &a;
```
```cpp
//잘못된 예시이다. 오류가 발생한다.
const int a = 1;
int *p = &a;
```
3번째 코드가 작동하지 않는 이유

포인터는 주소값에 접근하기 때문에 제한자의 의미가 사라지므로 C++표준에서 막아두었다\.

여러 오류를 막기위해 포인터에서 가능한 const를 사용한다.

아래처럼 모호한 조합이 나오기도 한다.
```cpp
int a = 0;
const int *p = &a; //p로 a 값을 바꿀 수 없다.
int * const p =&a; //p가 가르키는 주소를 바꿀수 없다.
```

---
#### 07.4 함수와 2차원 배열

배열의 주소(배열이름)와 배열의 열 개수를 넘겨주면 매개변수로 사용 가능하다.

포인터가 배열의 열 개수 만큼 포인터의 비트 크기를 늘린다.

```cpp
#include <iostream>
using namespace std;
void sample(int arr[][3]);

int main()
{
    int data[2][3] = { {1,2,3},{4,5,6} };
    cout << data << endl;
    sample(data);
}

void sample(int arr[][3])
{
    cout << &arr[0] << endl
         << "arr[1][0] : " << arr[1][0] <<endl
         << "*(*(arr+1)+0) : " << *(*(arr+1)+0);
    return;
}
//출력값 :
//0x7fff06dfbfa0
//0x7fff06dfbfa0
//arr[1][0] : 4
//*(*(arr+1)+0) : 4
```

---
#### 07.5 함수와 C스타일의 문자열

**문자열을 나타내는 방법 3가지**
- char형의 배열
- 큰따옴표로 묶은 문자열 상수(문자열 리터럴)
- 문자열의 주소로 설정된 char형을 지시하는 포인터

문자열 또한 포인터를 이용하기 때문에 매개변수로 사용할 때에도 첫 문자의 주소를 전달한다.

 C스타일 문자열은 마지막에 null종결문자가 존재하기 때문에 문자열의 크기를 전달할 필요가 없다.
 
 루프를 사용해 null종결문자까지 가야한다.
 
**C스타일 문자열을 리턴하는 함수**
C스타일 문자열은 리턴할 수 없다.
문자열의 주소는 리턴할 수 있다.
new를 사용하여 문자열을 생성하고 문자열을 초기화한후 포인터를 리턴 할 수 있다.

---
#### 07.6 함수와 구조체

구조체는 매개변수에서 복사본으로 사용한다. 기본형과 똑같이 처리된다.

구조체가 규모가 큰 경우 성능저하의 요인이 될 수 있어 포인터를 사용한다.

**구조체 주소의 전달**
- 함수 호출시 구조체의 주소를 전달한다.
- 구조체를 지시하는 포인터를 매개변수로 선언한다.
- 멤버 연산자(.) 대신 간점 멤버 연산자(->)를 사용한다.

---
#### 07.7 함수와 string 클래스 객체

string 객체는 내장 데이터형처럼 사용하면 된다.
```cpp
#include <iostream>
#include <string>
using namespace std;
string sample(string);

int main()
{
    string s = "매개변수 받았습니다.";
    s = sample(s);
    cout << s;
}

string sample(string s)
{
    cout << s << endl;
    return "리턴값 받았습니다.";
}
//출력 :
//매개변수 받았습니다.
//리턴값 받았습니다.
```

---
#### 07.8 함수와 array객체

array는 클래스 객체로 사용한다.

클래스 객체는 구조체에 기반을 두고있어 구조체처럼 사용한다.

값이 필요한 것 이라면 객체를 매개변수로 사용하고

값을 변경하기 위한 것 이라면 객체의 주소를 매개변수로 사용한다.

---
#### 07.9 재귀 호출

`main()`함수를 제외한 함수는 자기 자신을 호출 할 수 있다.

**단일 재귀호출**
```cpp
#include <iostream>
using namespace std;
void recur(int a, int b);

int main()
{
    int c = 1;
    recur(c, 0);
}

void recur(int a, int b)
{
    if (b<5)
    {
        cout << &a << endl;
        recur(a , ++b);
    }
    return;
}// 재귀시 마다 같은 변수를 호출해도 다른 주솟값을 가지고 있다.
//출력값 :
//0x7ffffd22dfbc
//0x7ffffd22df9c
//0x7ffffd22df7c
//0x7ffffd22df5c
```

**다중 재귀 호출**

분할정복 전략 문제에 효율적이다.

재귀 호출이 과도하게 많을 경우 효율적이지 않다.

분할 정복 전략 - 큰 문제를 작은 문제로 분할하여 해결하는 전략

---
#### 07.10 함수를 지시하는 포인터

함수 또한 주소를 가지고 있다. 위치는 기계어 코드가 저장되어있는 메모리 블록의 시작 주소이다.

일반적으로는 필요하지 않다.

특수한 프로그램에서 유용할 수 있다.

**함수 포인터의 기초**

세 단계를 통해 사용 가능하다.
1. 함수의 주소를 얻는다
2. 한수를 지시하는 포인터를 선언한다.
3. 함수를 지시하는 포인터를 사용하여 그 함수를 호출한다.


**함수 주소 얻기**

함수 이름만 사용하면 주소를 얻는다.

**함수를 지시하는 포인터 선언**

함수원형에서 함수이름자리에 포인터명을 적는다.
```cpp
//주의
int (*fp)(int); //int형을 리턴하는 함수를 가르키는 포인터
int *fp(int); //int형을 가르키는 포인터를 리턴하는 함수
```

포인터를 사용하여 함수 불러내기
```cpp
int a = (*fp)(1); //이 구문은 당연히 성립한다.
int a = fp(1); //이 구문 또한 C++에서 허용한다.
```

**함수 포인터의 변형**

```cpp
int * f1(int ar[]);
int * f2(int []);
int * f3(int *);
```
위 3가지 함수원형은 모두 같은 함수이다. 함수 원형은 식별자를 생략 가능하다.

하지만 정의에서는 식별자를 제공해야한다.

3개의 함수를 배열에 집어 넣을 수 있다. (=배열안에 있는 함수를 반복문을 통해 실행 가능하다.)
```cpp
int * (*pa[3]) (int *) = {f1, f2, f3};
//해설 :
//pa[3] : 길이가 3짜리 배열
//*pa[3] : 포인터가 들어있는 길이가 3짜리 배열
//int * (*pa[3]) (int *) :
//int의 포인터를 매개변수로 가지고, int형을 반환하는 함수의 포인터가 들어있는 길이가 3짜리 배열
```
**auto**
포인터의 복잡한 선언을 짧게 줄여줄 수있다
`auto pc = &p;`

**typedef을 이용한 단순화**
`typedef double real;` // double에 real이라는 가명을 만든다.
복잡한 함수의 포인터형의 배열을 만들때 오류를 줄여줄 수있다.

