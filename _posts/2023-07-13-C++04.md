# 04 복합 데이터형

---

### 04.1 배열

배열(array) - 데이터 형이 같은 여러 개의 값을 연속적으로 저장할 수 있는 데이터 구조

배열을 선언하는데 필요한 요소

- 각 원소에 저장될 값의 데이터형
- 배열의 이름
- 배열 원소의 개수

```cpp
데이터형 배열명[원소의 개수];
```

배열  원소의 개수는 숫자 또는 const 기호상수와 같은 정수 상수이거나 컴파일할 때 값이 결정되는 상수 수식이여야 한다. 변수는 될 수 없다.

배열은 복합 데이터 형이다.

배열은 다른 특정 데이터형을 통해 만들어진다. 배열만 존재할 수 없다.

배열이 유용한 것은 각각의 배열 원소에 개별적으로 접근 가능하기 떄문이다.

0부터 시작하는 인덱스가 개별적인 접근을 허용한다.

적절한 인덱스 사용의 중요성

컴파일러가 적법한 인덱스를 사용하는지 검사하지 않는다.

배열 초기화 규칙

```cpp
데이터형 배열명[원소의 개수] = {원소1,원소2,...,원소n};
```

- 초기화 형식은 배열을 정의한 곳에서만 사용 가능하다.
- 추후에 값을 넣고 싶으면 인덱스 하나하나에 직접 대입해야 한다.
- 원소의 개수>n 이면 n이후의 원소들은 0으로 초기화 된다.
- 초기화 할 때 원소의 개수 자리를 비워두면 n개로 원소의 개수를 결정한다.

C++11 배열 초기화

1. 배열을 초기화 할때 =부호를 사용하지 않아도 된다.
2. 중괄호를 공백으로 두면 모든 배열을 0으로 초기화 한다.
3. 리스트 초기화 시에 narrowing을 방지할 수 있다.

---

### 04.2 문자열

메모리에 바이트 단위로 연속적이게 저장되어있는 문자들을 말한다.

C++은 두 가지 방식으로 문자열을 처리한다.

1. C에서 사용하던 문자열 처리 방법
2. string 클래스 라이브러리를 사용하는 방법 (다음 챕터에 설명)

C++은 문자열 길이에 제한을 두지 않는다.

**char형의 배열로 구성된 문자열**

문자들을 char형 배열에 저장한다.

마지막 문자는 반드시 *널 문자이다.

*널 문자(null character) - ascii에서 0의 주소를 가지고 \0으로 쓰인다. 문자열의 끝을 표시한다.

리스트 초기화 방식을 사용하는 것이 아닌 큰따옴표 안에 문자열을 넣으면 널 문자를 포함한 문자열을 생성한다.

**문자열 상수의 결합**

문자열 상수들은 코드상에서 화이트 스페이스(white space)로 분리되어도 하나의 문자열 상수로 결합된다.

**배열에 문자열 사용**

배열에 문자열을 넣는 방법은 2가지 이다. 문자열 상수로 초기화 하는 방법, 키보드 입력이나 파일 입력을 배열에 저장하는 방법

tip

배열의 크기를 기호 상수로 나타내면 배열 크기를 바꾸어야 할 때 코드를 수정하기 쉽다.

**문자열 입력**

cin이 문자열의 끝을  null을 인식해 처리한다. 키보드로 null 입력이 불가능해 white space로 대체한다. 따라서 입력을 받을 때 하나의 단어만 읽을 수 있는 것이다,

입력한 문자열이 문자열을 저장할 배열보다 더 길 수도 있다.

**한 번에 한 행의 문자열 입력 읽기**

행 단위로 문자열을 입력하는 클래스 멤버 함수는 istream파일의 cin 클래스에 두 가지가 존재한다.

1. getline()
2. get()

둘 다 개행문자가 나올 때까지 읽는다.

getline()은 개행문자를 읽어서 폐기하고,  get()은 입력 큐에 개행문자를 남겨 둔다.

**getline()을 이용한 행 단위 입력**

```cpp
cin.getline(변수명, 원소개수);
```

getline() 함수는 Enter 키에 의해 전달되는 개행문자를 입력의 끝으로 간주하여 한 행 전체를 읽는다.

**get()을 이용한 행 단위 입력**

```cpp
cin.get(변수명, 원소개수);
cin.get(); //개행 문자를 비워주기 위해 한번 읽어서 처리한다.

cin.get(변수명,원소개수).get(); //이렇게 한줄로 작성도 가능하다.
```

get() 함수는 개행문자를 읽어서 버리지 않고 입력 큐에 그대로 남겨둔다.

get()함수를 연속해서 사용하려면 남은 개행문자를 한번 비워야 한다. 매개변수가 없는 get()함수가 개행문자를 읽어서 처리 할 수 있다.

get을 사용하는 이유

- 구식 C++에는 getline()이 없다.
- 사용자를 신중하게 만든다
- getline()은 사용이 편하고 get()은 에러체킹이 쉽다.

cin은 수치를 읽어 들이고 개행문자를 입력 큐에 남겨두기 때문에 문제가 발생 할 수 있다.

- 개행문자를 지우는 과정이 필요하다.

---

### 04.3 string 클래스

C++ 표준은 string 클래스를 추가 하여 C++ 라이브러리를 확장시켰다.

string 헤더 파일을 포함시켜야 한다.

#include<string>

std이름공간 속에 있다. using 지시자를 사용하거나  std::string을 사용하여 클래스를 참조해야한다.

string객체를 문자 배열과 동일한 방식으로 사용할 수 있다.

- C스타일 문자열로 string 객체를 초기화 할 수 있다.
- cin을 사용하여 string 객체에 키보드 입력을 저장할 수 있다.
- cout을 사용하여 string 객체를 디스플레이 할 수 있다.
- 배열 표기를 사용하여 string 객체에 저장되어있는 개별적인 문자들에 접근 할 수 있다.

string 객체와 문자 배열의 가장 큰 차이점

변수 선언을 배열이 아닌 단순 변수로 선언한다. 크기 문제를 string 객체가 자동으로 처리하도록 한다.

C++11 문자열 초기화

```cpp
char A[] ={"aaaaa"};
string B = {"bbbbb"};
```

위와 같은 방식으로 리스트 초기화를 가능하게 해준다.

**대입, 결합, 추가**

배열보다 조작이 간단하다. 하나의 배열을 다른 배열에 간단하게 대입 할 수 없지만 하나의 string 객체를 다른 string객체에 간단하게 대입 가능하다.

문자열 결합을 간단하게 처리한다

- +연산자를 사용하여 2개의 string 객체를 결합한다.
- +=연산자를 이용하여 기존의 string 객체 끝에 또 다른 객체를 덧붙일 수 있다.
- C스타일 문자열을 대입 가능하다

**string 클래스의 조작**

cstring 헤더파일에는 C 스타일의 문자열들을 대상으로 strcpy() 함수를 통해 문자열을 문자 배열에 복사하고, srtcat() 함수를 사용해 문자열을 문자 배열에 추가하는 조작을 할 수 있다.

이 경우 목적지 배열이 더 작은 경우 배열 이외의 메모리 공간에 침범할 가능성이 생긴다.

stirng 클래스는 길이를 자동으로 조절하여 문제를 피한다.

C 스타일 문자열은  strncat(), strncpy()를 사용 가능하다. 타깃 베열의 최대 허용 크기를 나타내는 세 번째 매개변수를 사용한다. 안전하지만 복잡하다.

```cpp
string객체.size();     //문자열에 들어있는 문자들의 개수를 리턴한다.
strlen(C스타일문자열); //문자배열에 들어있는 문자들의 개수를 리턴한다.
```

**string 클래스의 입출력**

cin과 cout을 동일하게 사용 가능하다.

입력 이전의 string객체의 문자열의 길이는 0이다.

한 행을 읽어 string 객체 안에 넣는 코드이다.

```cpp
getline(cin,string객체);
```

**다른 형태의 문자열 상수**

```cpp
wchar_t A[] = L”aaaaa”
char16_t B = u”bbbbb”
char 32_t C = U”ccccc”
```

위는 문자열 상수 초기화 시에 확장 문자 코드를 가지는 접두사들의 사용 예시이다.

C++에서 지원하는 raw 문자열이 있다.

문자들이 각각 독립적으로 존재한다.(개행문자, 특수기호들이 문자가 된다)

구분자를 기본 문자 셋의 멤버로 사용이 가능하다. (구분자를 바꾸어 기존에 사용하던 구분자를 문자열로 사용 가능하다.)

---

### 04.4 구조체

여러가지 데이터 형을 가진 정보를 하나의 단위로 저장할 수 있는 것이 구조체(structure)이다.

구조체 또한 배열을 사용 가능하다.

클래스의 기초가 된다.

사용자가 정의할 수 있는 데이터 형이다. 2단계로 사용 가능하다.

1. 구조체 서술(structure decription)을 정의하는 단계
2. 구조체 서술에 따라 구조체 변수(structure variable)을 생성하는 단계

**구조체 선언**

```cpp
struct 구조체태그
{
	데이터형 멤버명; //이 라인이 여러개 존재할 수 있다.
};
```

C++에서는 구조체 태그를 기본 데이터형의 이름처럼 사용 가능하다.

구조체 변수 선언시에 struct 키워드가 필요 없다.

멤버 연산자(.)를 사용하여 구조체의 개별 멤버에 접근 할 수 있다.

```cpp
구조체변수명.멤버명
```

**구조체 선언을 두는 위치**

- main() 함수 여는 중괄호 바로 뒤에 선언 - 내부선언
- main() 함수 바로 앞에 선언 - 외부 선언(external declaration)

내부 선언은 해당 함수만 사용 가능하다.

**C++11의 구조체 초기화**

리스트 초기화 기능을 확장시킨다.

공백을 가지는 중괄호는 각각의 멤버에 대해 0으로 초기화 한다.

**구조체가 string 클래스 멤버를 사용할 수 있을까?**

컴파일러가 오래된 것이 아니라면 가능하다.

**구조체의 기타 특성**

구조체 선언과 구조체 변수 생성을 하나로 결합 가능하다.

구조체 선언의 중괄호 뒤에 변수명을 둔다.

일반적으로는 분리해 둔다.

태그명을 생략해 데이터 형 이름이 없는 구조체도 생성 가능하다.

position이라는 구조체 변수를 생성한다. 일반적으로 사용 가능하다.

**구조체의 배열**

구조체 배열을 초기화 하려면

```cpp
태그명 변수명[]=
{
{배열원소1구조체},
{배열원소2구조체},
};
```

**구조체 안의 비트 필드**

하드웨어 장치의 레지스터에 대응하는 데이터 구조를 만들때 편리하다.

구조체 멤버들이 일정 비트 수를 차지하도록 지정 가능하다.

구조체 선언할 때 멤버 뒤에 콜론을 찍고 그 뒤에 비트 수를 적는다.

```cpp
struct 구조체태그
{
	데이터형 멤버명 : n; //이러면 n비트를 가진다.
};
```

---

### 04.5 공용체

공용체(union)는 서로 다른 데이터형을 한번에 한 가지만 보관할 수 있는 데이터 형이다.

구문은 구조체와 같다.

```cpp
union 공용체명
{
	자료형 변수명; //여러 자료형으로 여러개 존재 할 수 있다.
};
```

여러 개의 데이터 형을 사용 가능하지만 한번에 한 값만 저장 가능하다. 중복 저장시 먼저 저장된 값이 소실된다.

공용체의 크기는 가장 큰 멤버의 크기가 된다.

여러가지 데이터형을 사용할 수는 있지만 동시에 사용 할 수 없을 때 메모리를 절약 가능하다.

---

### 04.6 열거체

열거형(enum)은 const를 사용하여 기호 상수를 만드는 것에 대한 다른 방식이다. 또한 제한적이지만 새로운 데이터형을 정의할 수 있다.

```cpp
enum Color {Red, Green, Blue};
```

enum형 변수를 열거체(enumeration)라 부른다.

enum의 원소를 열거자(enumerator)라 부른다.

기본적으로 첫 번째 열거자는 0이 대입되고, 두 번째 열거자에 1이 대입되는 방식으로 정수값들이 차례로 대입된다. 다만, 열거자에 정수값을 명시적으로 대입할 수 있다.

```cpp
enum Color {Red = 5, Green, Blue = 10};//Red = 5, Green = 6, Blue = 10
```

열거체 변수에는 사용된 열거자 값들만 대입할 수 있다.

```cpp
Color col;

col = Color::Blue;//문제 없음col = blue;//문제 없음col = 2000;//에러
```

열거체는 대입 연산자만 사용가능하다. 산술연산이 허용되지 않는다.

일부 C++에서는 ++연산자를 사용 가능하게 하지만 이식성을 위해 제한을 지키는 것이 좋다.

**열거체의 규칙은 매우 제한적이다.**

새로운 데이터형을 정의하는 것이 아닌 상호 관련이 있는 기호 상수들을 정의하는 용도로 주로 사용한다.

상수만 사용한다면 열거체 이름을 생략 가능하다.

**열거자 값의 설정**

- 대입 연산자를 사용하여 열거자의 값을 명시적으로 지정 가능하다.
- 대입값은 정수여야 한다.
- 대입값이 부족한 경우에 first는 0이다.
- 초기화 하지 않은 열거자들은 앞의 열거자 보다 1 크다.

**열거체의 값 범위**

열거체는 값 범위를 가지며, 대입되는 정수의 값이 열거자에 없어도 값 범위안에 들어온다면, 데이터형 변환을 통해 열거체 변수에 대입할 수 있다. 값 범위는 아래와 같다.

- 상한 : 열거자 값 중 최대값 보다 큰 2의 최소 거듭제곱에서 1을 뺀다.
- 하한 : 열거자 값 중 최소값이 0이거나 0보다 크면 값 범위의 하한은 0이고, 음수이면 상한과 같은 식으로 구한 후 음수

값 범위를 정의하는 것은 컴파일러가 열거체를 보관하기 위해 얼마만큼의 공간을 대입하느냐와 관계가 있다.

---

### 04.7 포인터와 메모리 해제

포인터(pointer)는 값이 아닌 값의 주소를 저장하는 변수이다.

일반적인 변수에 대해 명시적으로 알아내는 방법은 주소연산자(&)를 변수 앞에 붙이면 변수의 주소를 알 수 있다.

변수의 주소는 16진수표기를 사용한다.

일반 변수는 값에 이름을 붙인 것으로 취급하고 주소를 파생되는 것으로 취급한다.

포인터는 주소에 이름을 붙인 것으로 취급하고 값을 파생되는 것으로 취급한다.

포인터의 이름은 주소를 나타낸다.

간접값(indirect value)연산자, 간접 참조(dereferencing) 연산자 *을 포인터 이름 앞에 붙이면 주소에 저장되어있는 값이 된다.

```cpp
int A = 1;
int *a = &a;
//A와 *a는 같다.
//&A와 a는 같다.
```

포인터 앞의 데이터 형은 포인터가 어떤 데이터 형을 지시할 것 인지를 의미한다.

**포인터의 위험**

포인터에 주소를 대입하지 않고 값을 저장하면 값이 어느 주소에 대입 되는지 모른다.

포인터를 사용할 때는 간접참조연산자를 사용하기 전에 반드시 적절한 주소로 초기화 시켜주어야 한다.

**포인터와 수**

일반적인 컴퓨터의 메모리 주소는 정수형으로 다루고 있지만, 포인터는 정수형이 아니다. 때문에 포인터에 정수를 직접 대입할 수 없다.

어떤 수를 주소로 사용하려면 데이터형 변환자를 사용해 주소형으로 바꾸어 주어야 한다.

**new를 사용한 메모리 대입**

new - 데이터 형을 보고 적당한 메모리를 찾아 주소를 리턴한다.

```cpp
데이터형 *포인터명 = new 데이터형;
```

**메모리 부족**

메모리가 부족하여 new의 메모리 대입 요청을 거부하는 경우 0 값을 리턴한다.

주소가 0인 포인터를 null pointer라고 부르고 데이터를 지시할 수 없다.

**delete를 사용한 메모리 해제**

사용이 끝난 메모리를 다시 사용 가능한 메모리로 환수하기 위해 delete 연산자를 사용한다.

delete는 new로 대입한 메모리 블록을 지시하는 포인터와 함께 사용한다.

new를 사용한 후에 값사용이 끝나면 메모리 누수가 발생할 수 있다.

해제한 메모리블록을 다시 해제하려고 시도하면 어떤 일이 벌어질지 알수 없다.

**new를 사용한 동적 배열 생성**

데이터의 크기가 커질수록 new를 사용하는 것이 효율적이다.

선언에 의해 생성되는 배열은 항상 메모리 공간을 사용한다. 정적 바인딩(static binding)이라 한다.

컴파일 시간에 배열이 생성된다.

new를 사용하면 배열을 실행 시간에 생성할 수 있고 필요 없으면 생성하지 않을 수 있다. 이 방식을 동적 바인딩(dynamic array)이라 한다.

```cpp
데이터형 *포인터명 = new 데이터형[원소의 개수];

delete [] 포인터명; //동적 배열을 해제
```

new와 delete를 사용할 때 다음과 같은 규칙을 지켜야 한다.

- new로 대입하지 않은 메모리는 delete로 해제하지 않는다.
- 같은 메모리 블록을 연달아 두번 delete로 해제하지 않는다.
- new[]로 메모리를 대입한 경우에는 delete []로 해제한다.
- new를 대괄호 없이 사용했으면 delete도 대괄호 없이 사용한다.
- 널 포인터에는 delete를 사용하는 것이 안전하다. (아무 일도 일어나지 않는다.)

**동적 배열의 사용**

선언 배열은 내부적으로 포인터를 사용하기 때문에 동적배열도 선어배열처럼 사용 가능하다.

*동적배열 = 동적배열[0] , 동적배열 = 선언배열 이다.

---

### 04.8 포인터, 배열, 포인터 연산

포인터와 선언 배열의 동등성은 내부적으로 배열을 처리하는 방법과 포인터 연산으로부터 온다.

포인터 연산 - 포인터 변수에 1을 더하면 값이 데이터 형의 바이트 수만큼 증가한다.

sizeof 연산자를 적용할 때에도 차이가 있다.

배열에서는 배열의 크기가 얻어지지만 포인터는 포인터의 크기가 얻어진다.

배열의 이름을 사용하면 &배열[0] 이 나오지만 &배열 을 사용하면 전체 배열의 주소를 출력한다.

배열의 포인터를 선언하고 초기화 하는 법

```cpp
데이터형 (*포인터명)[원소개수] = &배열; // *포인터명과 배열이 동일하다.
```

**포인터와 문자열**

C스타일 문자열 또한 배열이기 때문에 포인터와 관계가 존재한다.

배열 이름은 첫 번째 원소의 주소이다, cout 객체는 문자열의 주소라고 간주하고 널(null) 문자까지 문자들을 출력한다.

문자열을 포인터로 지정하려면 포인터와 문자열을 지시하도록 하면 된다.

**new를 사용한 동적 구조체의 생성**

new를 사용하여 동적 구조체를 생성할 수 있다.

구조체 멤버에 접근할 때에는 도트(.) 멤버 연산자를 사용하는 것이 아닌, 화살표 멤버 연산자(->)를 사용해야 한다.

다른 방법은 (*포인터명).멤버명 으로 접근하는 방법이다. 연산자 우선순위 떄문에 괄호가 반드시 필요하다.

**자동공간, 정적공간, 동적공간**

C++에서는 데이터를 저장해 두기 위한 메모리를, 대입하는 방법에 따라 자동 공간(automatic storage), 정적 공간(static storage), 동적 공간(dynamic storage)으로 구분한다.

**자동 공간(automatic storage)**

함수 안에서 정의되는 보통의 변수들을 자동 변수(automatic variable)라고 한다. 자동 변수들은 함수가 호출되는 순간에 생겨나 그 함수가 종료되는 시점까지만 존재한다는 것을 뜻한다.

다른 말로 **스택(stack) 영역**이라고 하며, 주로 스택 영역으로 알고 있다. 스택에 저장되는 값은 순차적으로 저장되고, 역순으로 해제된다. 이를 후입선출(last-in first out : LIFO)라고 부른다.

**정적 공간(static storage)**

프로그램이 실행되는 동안에 지속적으로 존재하는 공간이다. 즉, 컴파일 타임때 생성되고, 프로그램 종료시 소멸된다.

변수를 정적으로 만드는 방법은 두 가지가 있다. 하나는 함수의 외부에서 변수를 정의하는 것이고, 하나는 함수 내부에서 static 키워드를 붙이는 것이다.

**동적 공간(dynamic storage)**

new 연산자를 사용하여 생성한 변수들은 동적 공간에 할당된다. 즉, 동적 할당한 변수들이 차지할 메모리 공간이다.

동적 할당한 시점에 생성되며, 개발자가 소멸하지 않으면 계속 남아 있다. 즉, 프로그램을 종료해도 남아 있어서 메모리 누수가 발생할 수 있다.

다른 말로 힙(heap) 영역이라고 한다.

---

### 04.9 변수형의 조합

배열, 구조, 포인터를 다양한 방법으로 조합 가능하다.

```cpp
struct Year
{
	‌int year;
};
```

위 구조체가 있을 때 아래와 같이 생성할 수 있다. 또한 도트 연산자를 사용하여 멤버에 접근할 수 있다.

```cpp
Year s01, s02, s03;
s01.year = 1998;
```

이러한 구조체에 대한 포인터를 생성할 수 있다.

```cpp
Year *pa = &s02;
```

포인터가 유효한 주소를 가리킬 경우, 화살표 연산자를 사용하여 멤버에 접근할 수 있다.

```cpp
pa->year = 1999;
```

구조체들의 배열을 생성할 수 있다. 또한 도트 연산자를 사용하여 원소의 멤버에 접근할 수 있다.

```cpp
Year trio[3];
trio[0].year = 2003;
```

trio는 배열이고, 배열의 이름은 포인터를 나타이므로, 화살표 멤버 연산자를 사용할 수 있다.

```cpp
(tior+1)->year = 2004;//trio[1].year = 2400;와 동일하다.
```

포인터 배열을 생성할 수 있다.

```cpp
const Year* arp[3] = { &s01, &s02, &s03 };
```

이 배열의 데이터에 접근하기 위해선 화살표 멤버 연산자를 사용해야 한다.

```cpp
std::cout << arp[1]->year << std::endl;
```

---

### 04.10 배열의 대안

**vector 템플릿 클래스**

vector 템플릿은 동적 배열에 속하는 string 클래스와 유사하다.

프로그램이 실행되는 동안 vector 객체의 크기를 설정할 수 있고, 새로운 데이터를 마지막에 추가하거나 중간에 데이터를 삽입할 수 있다.

기본적으로 동적 배열을 생성하기 위에 new를 사용하는 것을 대체할 수 있다. 실제로 vector 클래스는 메모리를 관리하기 위해서 new와 delete를 자동으로 사용한다.

```cpp
#include<vector> //헤더파일이 필요하다.
using namespace std; //std이름공간의 일부분이다.
```

vector 클래스는 자료형와 원소의 개수를 지정하기 위해 다른 구문을 사용한다.

vector의 기본형

```cpp
std::vector<자료형> vt(원소개수);
```

자동으로 크기가 조정되기때문에 원소개수가 없어도 상관없다.

**array 템플릿 클래스**

vector 클래스는 내재 배열 형보다 많은 기능을 지니고 있지만, 비효율적인 면이 있다.

고정된 크기의 배열만 필요할 경우  array 템플릿 클래스를 사용해 볼만하다. 내재 배열과 유사한 효율성을 지닌다.

```cpp
#include<array>//헤더파일이 필요하다
```

array의 기본형

```cpp
std::array<자료형, 원소개수> arr;
```

원소개수는 생략할 수 없고, 변수도 될 수 없다. 이는 배열과 똑같다.

vector 객체, array객체 비교

|  | Vector | Array |
| --- | --- | --- |
| 생성 (Creation) | 요소들을 순차적으로 저장할 수 있는 컨테이너 | 인덱스 기반 기본 자료구조 |
| 메모리 (Memory) | 배열 보다 메모리 공간 더 차지 | 메모리 효율성 높음 |
| 길이 (Length) | 동적으로 달라질 수 있음 | 고정된 길이 |
| 사용 (Usage) | 요소의 삽입과 삭제가 빈번하게 발생 | 요소에 접근이 빈번하게 발생 |
| 크기 조정 (Resize) | 동적으로 이루어짐 | 비용이 많이 듬 |
| 구조 (Structure) | Template 클래스 | 연속적인 메모리 공간 |
| 인덱싱 (Indexing) | 인덱스 기반 아님 | 인덱스 기반, 가장 낮은 주소가 첫 번째를 지칭하고 가장 높은 주소가 마지막 원소를 지칭 |
| 접근 (Access) | 위치에 기반하더라도 요소에 접근하는 것은 시간 소모적 | 요소의 위치에 무관하게 접근에 걸리는 시간은 일정함 |
